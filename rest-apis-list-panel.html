<!--
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/utils/render-status.html">
<link rel="import" href="../paper-toast/paper-toast.html">
<link rel="import" href="../paper-progress/paper-progress.html">
<link rel="import" href="../arc-icons/arc-icons.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="rest-apis-list-item.html">

<dom-module id="rest-apis-list-panel">
  <template>
    <style>
    :host {
      display: block;
      @apply --rest-apis-list-panel;
    }

    .header {
      @apply --layout-horizontal;
      @apply --layout-center;
    }

    h2 {
      margin-left: 16px;
      @apply --arc-font-headline;
      @apply --layout-flex;
    }

    [hidden] {
      display: none !important;
    }

    paper-progress {
      width: 100%;
      @apply --rest-apis-list-panel-loader;
    }

    paper-icon-button {
      border-radius: 50%;
      min-width: 40px;
      min-height: 40px;
    }

    paper-icon-button[active] {
      background-color: var(--rest-apis-list-panel-toggle-view-active-background-color, #00A1DF);
      color: var(--rest-apis-list-panel-toggle-view-active-color, #fff);
    }

    .error-toast {
      background-color: var(--warning-primary-color, #FF7043);
      color: var(--warning-contrast-color, #fff);
      @apply --error-toast;
    }

    .empty-info {
      margin-left: 16px;
      font-size: 16px;
      @apply --empty-info;
    }

    .header-actions {
      @apply --layout-horizontal;
      @apply --layout-center;
    }

    .header-actions paper-input {
      @apply --layout-flex-2;
      margin-left: 16px;
    }

    .list {
      @apply --layout-vertical;
    }

    .explore-button {
      margin-right: 12px;
      @apply --rest-apis-list-panel-explore-button;
    }
    </style>
    <div class="header">
      <h2>REST APIs</h2>
      <div class="header-actions">
        <template is="dom-if" if="[[renderExplore]]">
          <paper-button raised on-click="_openExplore" class="explore-button" data-action="explore-apis">Explore APIs</paper-button>
        </template>
        <paper-input id="search" type="search" value="{{query}}" label="Search" no-label-float></paper-input>
      </div>
    </div>
    <template is="dom-if" if="[[querying]]">
      <paper-progress indeterminate></paper-progress>
    </template>
    <template is="dom-if" if="[[dataUnavailable]]">
      <p class="empty-info">REST APIs list is empty. Drag and drop RAML zip file here to begin.</p>
    </template>
    <section class="list" hidden$="[[listHidden]]">
      <template is="dom-repeat" items="[[items]]" id="list">
        <rest-apis-list-item item="[[item]]" on-open-list-item="_navigateItem" on-delete-list-item="_deleteItem" noink="[[noink]]"></rest-apis-list-item>
      </template>
    </section>
    <paper-toast id="errorToast" class="error-toast" duration="5000"></paper-toast>
    <paper-toast id="noModel" class="error-toast" text="Model not found. Please, report an issue."></paper-toast>
    <paper-toast id="deletedToast" text="API data has been removed from the datastore"></paper-toast>
  </template>
  <script>
  /**
   * REST APIs project list screen
   *
   * This element requires `arc-models/rest-api-model` element to be present in the
   * DOM as this element does not connect to the datastore directly.
   * The `arc-models/rest-api-model` element can be replaced by any element that
   * supports the same event's API.
   *
   * ### Example
   *
   * ```html
   * <link rel="import" href="../rest-apis-list-panel/rest-apis-list-panel.html">
   * <link rel="import" href="../arc-models/rest-api-model.html">
   *
   * <rest-apis-list-panel></rest-apis-list-panel>
   * <rest-api-model></rest-api-model>
   * ```
   *
   * ### Styling
   *
   * `<rest-apis-list-panel>` provides the following custom properties and mixins for styling:
   *
   * Custom property | Description | Default
   * ----------------|-------------|----------
   * `--rest-apis-list-panel` | Mixin applied to the element | `{}`
   * `--rest-apis-list-panel-loader` | Mixin applied to the paper-progress element | `{}`
   * `--arc-font-headline` | Mixin applied to the header | `{}`
   * `--arc-font-subhead` | Mixin applied to the subheader | `{}`
   * `--warning-primary-color` | Main color of the warning messages | `#FF7043`
   * `--warning-contrast-color` | Contrast color for the warning color | `#fff`
   * `--error-toast` | Mixin applied to the error toast | `{}`
   * `--empty-info` | Mixin applied to the label rendered when no data is available. | `{}`
   *
   * @polymer
   * @customElement
   * @memberof UiElements
   * @demo demo/index.html
   */
  class RestApisListPanel extends Polymer.Element {
    static get is() {
      return 'rest-apis-list-panel';
    }
    static get properties() {
      return {
        /**
         * Saved items restored from the datastore.
         */
        items: Array,
        /**
         * True when the element is querying the database for the data.
         */
        querying: {
          type: Boolean,
          readOnly: true,
          notify: true
        },
        /**
         * Computed value, true if the `items` property has values.
         */
        hasItems: {
          type: Boolean,
          value: false,
          computed: '_computeHasItems(items.length)',
          notify: true
        },
        /**
         * Computed value. True if query ended and there's no results.
         */
        dataUnavailable: {
          type: Boolean,
          computed: '_computeDataUnavailable(hasItems, querying)'
        },
        /**
         * Page token for datastore pagination.
         */
        nextPageToken: String,
        /**
         * Search query for the list.
         */
        query: String,
        /**
         * If true, the element will not produce a ripple effect when interacted
         * with via the pointer.
         */
        noink: Boolean,
        /**
         * Computed value, true if the requests lists is hidden.
         */
        listHidden: {
          type: Boolean,
          computed: '_computeListHidden(hasItems, isSearch)'
        },
        /**
         * If set it renders the "Explore APIs" button
         */
        renderExplore: Boolean
      };
    }

    constructor() {
      super();
      this._onDatabaseDestroy = this._onDatabaseDestroy.bind(this);
      this._indexUpdated = this._indexUpdated.bind(this);
      this._indexDeleted = this._indexDeleted.bind(this);
      this.updateSearch = this.updateSearch.bind(this);
    }

    connectedCallback() {
      super.connectedCallback();
      window.addEventListener('datastore-destroyed', this._onDatabaseDestroy);
      window.addEventListener('api-index-changed', this._indexUpdated);
      window.addEventListener('api-deleted', this._indexDeleted);
      this._requery();
      this.$.search.inputElement.addEventListener('search', this.updateSearch);
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      window.removeEventListener('datastore-destroyed', this._onDatabaseDestroy);
      window.removeEventListener('api-index-changed', this._indexUpdated);
      window.removeEventListener('api-deleted', this._indexDeleted);
      this.$.search.inputElement.removeEventListener('search', this.updateSearch);
    }
    /**
     * Resets the state of the variables.
     */
    reset() {
      if (this.nextPageToken) {
        this.nextPageToken = undefined;
      }
      this._setQuerying(false);
      this.set('items', []);
    }
    /**
     * Resets the state after finishing search. It restors previous items
     * without changing query options.
     */
    _resetSearch() {
      this.set('items', this._beforeQueryItems);
      this.isSearch = false;
      this._beforeQueryItems = undefined;
      if (!this.items) {
        this.refresh();
      }
    }
    /**
     * Refreshes the data from the datastore.
     * It resets the query options, clears items and makes a query to the datastore.
     */
    refresh() {
      this.reset();
      this.makeQuery();
    }

    _requery() {
      if (!this.items && !this.querying) {
        this.makeQuery();
      }
    }

    // Handler for the `datastore-destroyed` custom event
    _onDatabaseDestroy(e) {
      let datastore = e.detail.datastore;
      if (!datastore || !datastore.length) {
        return;
      }
      if (typeof datastore === 'string') {
        datastore = [datastore];
      }
      if (datastore.indexOf('rest-api-index') === -1 && datastore[0] !== 'all') {
        return;
      }
      this.reset();
    }

    /**
     * Computes value for the `hasItems` property.
     * @param {Number} length Current size of items
     * @return {Boolean}
     */
    _computeHasItems(length) {
      return !!(length);
    }
    /**
     * The function to call when new query for data is needed.
     */
    makeQuery() {
      if (this.__queryDebouncer) {
        return;
      }
      this.__queryDebouncer = true;
      setTimeout(() => {
        this.__queryDebouncer = false;
        this._loadPage();
      }, 20);
    }
    /**
     * Performs the query and processes the result.
     * @return {Promise}
     */
    _loadPage() {
      this._setQuerying(true);
      const detail = {};
      if (this.nextPageToken) {
        detail.nextPageToken = this.nextPageToken;
      }
      const e = new CustomEvent('api-index-list', {
        bubbles: true,
        composed: true,
        cancelable: true,
        detail
      });
      this.dispatchEvent(e);
      if (!e.defaultPrevented) {
        this._setQuerying(false);
        console.warn('REST API model detached from the DOM.');
        return;
      }
      return e.detail.result
      .then((result) => {
        this.nextPageToken = result.nextPageToken;
        return result.items;
      })
      .then((items) => {
        if (!items || !items.length) {
          this._setQuerying(false);
          return;
        }
        if (!this.items) {
          items.sort(this._sortData);
          this.set('items', items);
        } else {
          const concat = this.items.concat(items);
          concat.sort(this._sortData);
          this.set('items', concat);
          this.shadowRoot.querySelector('#list').render();
        }
        this._setQuerying(false);
        setTimeout(() => {
          this._loadPage();
        }, 10);
      })
      .catch((e) => {
        this._setQuerying(false);
        console.error('Query menu items', e);
      });
    }
    /**
     * Sorts projects list by `order` and the `title` properties.
     * @param {Object} a
     * @param {Object} b
     * @return {Number}
     */
    _sortData(a, b) {
      if (a.order < b.order) {
        return -1;
      }
      if (a.order > b.order) {
        return 1;
      }
      return a.title.localeCompare(b.title);
    }
    /**
     * Computes value for the `dataUnavailable` property.
     * @param {Boolean} hasItems Current value of `hasItems`
     * @param {Boolean} querying Current value of `querying`
     * @return {Boolean}
     */
    _computeDataUnavailable(hasItems, querying) {
      return !hasItems && !querying;
    }

    /**
     * Handler for the `api-index-changed` custom event.
     * Only handles the change if the event is non-cancelable.
     *
     * @param {CustomEvent} e
     */
    _indexUpdated(e) {
      if (e.cancelable) {
        return;
      }
      const item = e.detail.apiInfo;
      if (this.isSearch) {
        this._indexUpdatedSearch(item);
        return;
      }
      if (!this.items) {
        this.set('items', [item]);
        return;
      }
      const index = this.items.findIndex((obj) => obj._id === item._id);
      if (index === -1) {
        this.push('items', item);
        this.items.sort(this._sortData);
        this.shadowRoot.querySelector('#list').render();
      } else {
        this.set(['item', index], item);
      }
    }
    /**
     * Updates a list item when the search is on.
     * @param {Object} item An item to update.
     */
    _indexUpdatedSearch(item) {
      if (!this._beforeQueryItems) {
        return;
      }
      // checks current visible items.
      let items = this.items;
      if (items && items.length) {
        const index = items.findIndex((obj) => obj._id === item._id);
        if (index > -1) {
          this.set(['items', index], item);
        }
      }
      // checks in-memory full list of items
      items = this._beforeQueryItems;
      if (!items) {
        this._beforeQueryItems = [item];
      } else {
        const index = items.findIndex((obj) => obj._id === item._id);
        if (index === -1) {
          items.push(item);
        } else {
          items[index] = item;
        }
        this._beforeQueryItems = items;
      }
    }
    /**
     * Handler for the `api-deleted` custom event.
     * @param {CustomEvent} e
     */
    _indexDeleted(e) {
      if (e.cancelable) {
        return;
      }
      const id = e.detail.id;
      if (this.isSearch) {
        this._indexDeletedSearch(id);
        return;
      }
      const items = this.items;
      if (!items || !items.length) {
        return;
      }
      const index = items.findIndex((item) => item._id === id);
      if (index === -1) {
        return;
      }
      this.splice('items', index, 1);
    }
    /**
     * Handles delete event when search is on.
     * Updates bothe `items` and `_beforeQueryItems` lists if removed item is on
     * any of those lists.
     * @param {String} id The ID of deleted item.
     */
    _indexDeletedSearch(id) {
      if (!this._beforeQueryItems) {
        return;
      }
      // checks current visible items.
      let items = this.items;
      if (items && items.length) {
        const index = items.findIndex((obj) => obj._id === id);
        if (index > -1) {
          this.splice('items', index, 1);
        }
      }
      // checks in-memory full list of items
      items = this._beforeQueryItems;
      if (items) {
        const index = items.findIndex((obj) => obj._id === id);
        if (index > -1) {
          items.splice(index, 1);
          this._beforeQueryItems = items;
        }
      }
    }

    updateSearch() {
      this.queryItems(this.query);
    }
    /**
     * Performs the search
     * @param {String} query An item to search for
     */
    queryItems(query) {
      if (!query) {
        this._resetSearch();
        return;
      }
      this.isSearch = true;
      if (!this._beforeQueryItems) {
        this._beforeQueryItems = this.items;
      }
      const availableItems = this.items;
      if (!availableItems || !availableItems.length) {
        this.set('items', undefined);
        return;
      }
      query = this._prepareQuery(query);
      const encodedQuery = encodeURIComponent(query);
      const matches = availableItems.filter((item) => {
        if (item._id.toLowerCase().indexOf(encodedQuery) !== -1) {
          return true;
        }
        if (item.title && item.title.indexOf(encodedQuery) !== -1) {
          return true;
        }
        if (item.description && item.description.indexOf(query) !== -1) {
          return true;
        }
        return false;
      });
      this.set('items', matches);
    }
    /**
     * Prepares the user query to be used in the datasore simple search.
     * @param {String} query User query
     * @return {String} Transformed query
     */
    _prepareQuery(query) {
      query = String(query);
      query = query.toLowerCase();
      if (query[0] === '_') {
        query = query.substr(1);
      }
      return query;
    }
    /**
     * Sends `navigate` event so the application can handle navigation to the
     * API project.
     * @param {CustomEvent} e
     */
    _navigateItem(e) {
      this.dispatchEvent(new CustomEvent('navigate', {
        bubbles: true,
        composed: true,
        detail: {
          base: 'api-console',
          id: e.detail._id
        }
      }));
    }
    /**
     * Dispatches cancelable `api-deleted` event for the model to delete
     * the entry.
     *
     * This requires `arc-models/rest-api-model` element to be present in the
     * DOM.
     * @param {CustomEvent} e
     */
    _deleteItem(e) {
      const ev = new CustomEvent('api-deleted', {
        bubbles: true,
        composed: true,
        cancelable: true,
        detail: {
          id: e.detail._id
        }
      });
      this.dispatchEvent(ev);
      if (!ev.defaultPrevented) {
        this.$.noModel.opened = true;
        return;
      }
      ev.detail.result.then(() => {
        this.$.deletedToast.opened = true;
      })
      .catch((cause) => {
        console.error(cause.message);
        this.$.errorToast.text = cause.message;
        this.$.errorToast.opened = true;
      });
    }

    /**
     * Computes value of the `listHidden` property.
     * List is hidden when no items are found and it is not searching.
     *
     * @param {Boolean} hasItems
     * @param {Boolean} isSearch
     * @return {Boolean}
     */
    _computeListHidden(hasItems, isSearch) {
      if (isSearch) {
        return false;
      }
      return !hasItems;
    }
    /**
     * Dispatches `navigate` event to open Exchange explorer.
     */
    _openExplore() {
      this.dispatchEvent(new CustomEvent('navigate', {
        bubbles: true,
        composed: true,
        detail: {
          base: 'exchange-search'
        }
      }));
    }

    /**
     * Dispatched when the user opens the API portal.
     *
     * @event navigate
     * @param {String} base `api-console` or `exchange-search`
     * @param {?String} id API datastore ID if `base` is `api-console`
     */

    /**
     * Dispatched automatically when the element becomes visible to request
     * API listing data from the datastore.
     *
     * @event api-index-list
     * @param {?String} nextPageToken Optional, page token returned with previous
     * query
     */

    /**
     * Dispatched when the user request to delete API entry.
     *
     * @event rest-api-deleted
     * @param {String} id Datastore id of the entry to be deleted
     */
  }
  window.customElements.define(RestApisListPanel.is, RestApisListPanel);
  </script>
</dom-module>
